

一、概念：闭包、柯里化
	1、闭包：就是函数的嵌套
	         在内函数中访问外函数的变量
		scala> //闭包：函数的嵌套

		scala> def mulBy(factor:Double)=(x:Double)=> x* factor
		mulBy: (factor: Double)Double => Double

		scala> //调用

		scala> //1、乘以3的操作，因子=3

		scala> val triple=mulBy(3)
		triple: Double => Double = <function1>

		scala> //值函数

		scala> triple(10)
		res0: Double = 30.0

		scala> //2、乘以0.5的操作 factor=0.5

		scala> val half = mulBy(0.5)
		half: Double => Double = <function1>

		scala> half(10)
		res1: Double = 5.0

	2、柯里化：柯里是一位数学家
		

二、集合
	1、可变集合、不可变集合-----（Map）
			scala> //不可变集合

			scala> val math = scala.collection.immutable.Map("Tom"->80,"Mary"->90,"Mike"->85)
			math: scala.collection.immutable.Map[String,Int] = Map(Tom -> 80, Mary -> 90, Mike -> 85)

			scala> //可变集合

			scala> val chinese = scala.collection.mutable.Map("Tom"->80,"Mary"->90,"Mike"->85)
			chinese: scala.collection.mutable.Map[String,Int] = Map(Mike -> 85, Tom -> 80, Mary -> 90)

			scala> //集合的操作

			scala> //1、获 取集合中的值

			scala> chinese.get("Mary")
			res2: Option[Int] = Some(90)

			scala> chinese("Mary")
			res3: Int = 90

			scala> //2、判断是否存在这个key

			scala> chinese("Bob")
			java.util.NoSuchElementException: key not found: Bob
			  at scala.collection.MapLike$class.default(MapLike.scala:228)
			  at scala.collection.AbstractMap.default(Map.scala:59)
			  at scala.collection.mutable.HashMap.apply(HashMap.scala:65)
			  ... 32 elided

			scala> if(chinese.contains("Bob")){
				 |      chinese("Bob")
				 | }else{
				 |    -1
				 | }
			res5: Int = -1

			scala> //简写

			scala> chinese.getOrElse("Bob")
			<console>:13: error: not enough arguments for method getOrElse: (key: String, default: => B1)B1.
			Unspecified value parameter default.
				   chinese.getOrElse("Bob")
									^

			scala> chinese.getOrElse("Bob",-1)	
			scala> //更新集合中的值：注意：必须是一个可变集合

			scala> chinese("Mary")
			res8: Int = 90

			scala> chinese("Mary")=95

			scala> chinese("Mary")
			res10: Int = 95

			scala> //添加新的元素

			scala> chinese += "Bob" -> 88
			res11: chinese.type = Map(Bob -> 88, Mike -> 85, Tom -> 80, Mary -> 95)

			scala> //移除元素

			scala> chinese -= "Bob"
			res12: chinese.type = Map(Mike -> 85, Tom -> 80, Mary -> 95)

			
	2、列表：不可变列表（List）\可变列表（LinkedList）
		scala> //字符串列表

		scala> val nameList = List("Bob","Tom","Mary")
		nameList: List[String] = List(Bob, Tom, Mary)

		scala> //整数列表

		scala> val intList = List(1,2,3)
		intList: List[Int] = List(1, 2, 3)

		scala> //空列表

		scala> val nullList:List[Nothing] = List()
		nullList: List[Nothing] = List()

		scala> //二维列表：类似二维数组

		scala> //通过列表的列表来实现

		scala> val dim:List[List[Int]]= List(List(1,2,3),List(10,20,30))
		dim: List[List[Int]] = List(List(1, 2, 3), List(10, 20, 30))	
		
		scala> println(nameList.head+"  ******   "+ nameList.tail)
		Bob  ******   List(Tom, Mary)

		scala> //val nameList = List("Bob","Tom","Mary")

		scala> //nameList.tail返回的不是最后一个元素，是：除去第一个元素后，剩下的元素	

		可变列表
			scala> //可变列表: scala.collection.mutable.LinkedList

			scala> //类似List,只是我们可以改变里面的值

			scala> val myList = scala.collection.mutable.LinkedList(1,2,3,4,5)
			warning: there was one deprecation warning; re-run with -deprecation for det
			myList: scala.collection.mutable.LinkedList[Int] = LinkedList(1, 2, 3, 4, 5)

			scala> //操作：对里面的每个元素乘以2

			scala> //类似：数据库的 游标、光标()cursor

			scala> //定义一个指针指向可变列表的开始

			scala> var cur = myList
			cur: scala.collection.mutable.LinkedList[Int] = LinkedList(1, 2, 3, 4, 5)

			scala> while(cur != Nil){
				 |    //把当前元素乘以2
				 |    cur.elem = cur.elem*2
				 |    //移动指针，指向下一个元素
				 |    cur = cur.next
				 | }

			scala> //Nil：相当于Null

			scala> //查看结果

			scala> println(myList)
			LinkedList(2, 4, 6, 8, 10)		
	
	3、序列：
		（*）数据库中也有序列：Sequence
			 以Oracle为例: 创建序列
			 create sequence myseq; 后面的参数可以不写
			 
			 Oracle中的序列就是一个整数的数组，一般来说，作用：
				（1）作为主键，实现自动的增长，类似MySQL中的auto increment
				（2）可以提高性能，序列是存在于Oracle的内存中
		
		（*）Scala中：常用的: Vector和Range
			scala> //Vector是一个带下标的序列

			scala> val v = Vector(1,2,3,4,5,6)
			v: scala.collection.immutable.Vector[Int] = Vector(1, 2, 3, 4, 5, 6)

			scala> //属于immutable包下，是一个不可变的

			scala> //Range: 是一个整数的序列

			scala> //第一种写法

			scala> println(Range(0,5))
			Range(0, 1, 2, 3, 4)

			scala> //第二种写法

			scala> println(0 until 5)
			Range(0, 1, 2, 3, 4)

			scala> //第三种写法

			scala> println(0 to 4)
			Range(0, 1, 2, 3, 4)

			scala> //两个Range可以相加

			scala> ('0' to '9') ++ ('A' to  'Z')
			res20: scala.collection.immutable.IndexedSeq[Char] = Vector(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C,

			scala> // 把Range转成List

			scala> 1 to 5 toList
			warning: there was one feature warning; re-run with -feature for details
			res21: List[Int] = List(1, 2, 3, 4, 5)

			scala>		
		
		
	4、集（Set）：不重复的元素的集合，默认是HashSet
			scala> //创建一个Set

			scala> var s1 = Set(1,2,10,8)
			s1: scala.collection.immutable.Set[Int] = Set(1, 2, 10, 8)

			scala> //往s1中添加元素：重复的  不重复的

			scala> s1 + 10
			res22: scala.collection.immutable.Set[Int] = Set(1, 2, 10, 8)

			scala> s1 + 100
			res23: scala.collection.immutable.Set[Int] = Set(10, 1, 2, 8, 100)

			scala> //创建一个课排序的Set

			scala> var s2 = scala.collection.mutable.SortedSet(1,2,3,10,8)
			s2: scala.collection.mutable.SortedSet[Int] = TreeSet(1, 2, 3, 8, 10)

			scala> //参考一下讲义	
			
		
		如果在SQL中执行集合运算，是有要求的！！！！
		  select A,B,C,D from ****
		  union
		  select X,Y,Z from ****
		  上面的语法是错的，不能执行集合运算
		  
		  
		  （*）参与运算的各个集合select，必须要列数和列的类型一致
	
	5、模式匹配：相当于Java中，switch..case语句，但是功能更强大
	
	
	6、样本类：case class
		定义：就是在class前，加上case关键字
	
		作用：（1）支持模式匹配：也相当于instanceof
		      （2）定义Spark SQL的schema：定义Spark SQL的表（DataFrame、DataSet）结构

三、Scala的高级特性
	（一）泛型
		1、泛型类：定义类的时候，可以带有一个泛型的参数
		
		2、泛型函数:也可以带有泛型的参数
			scala> //泛型函数

			scala> //定义一个函数：创建一个Int类型的数组

			scala> def mkIntArray(elem:Int*) = Array[Int](elem:_*)
			mkIntArray: (elem: Int*)Array[Int]

			scala> mkIntArray(1,2,3,4,5)
			res28: Array[Int] = Array(1, 2, 3, 4, 5)

			scala> //定义一个函数，创建 一个String类型的数组

			scala> def mkStringArray(elem:String*) = Array[String](elem:_*)
			mkStringArray: (elem: String*)Array[String]

			scala> mkStringArray("abc","xyz")
			res29: Array[String] = Array(abc, xyz)

			scala> //问题：能否创建一个通用的函数，可以创建整数的数组，也可以创建String类型数组
			
			import scala.reflect.ClassTag
			def mkArray[T:ClassTag](elem:T*) = Array[T](elem:_*)
			
			调用:
			mkArray(1,2,3)
			mkArray("abc","xyz")
			
			解释ClassTag???? 参考讲义


		
		3、上界和下界：upper bound、lower bound
		               作用：是规定泛型的取值范围
					   
					   
					   
		4、视图界定：View bound
					 其实是上界和下界的一种扩展
					 
		5、协变和逆变
					   
	
	（二）隐式转换





















